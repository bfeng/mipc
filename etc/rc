# /etc/rc - System startup script run by init before going multiuser.

. /etc/rc.subr.minix

exec >/dev/log
exec 2>/dev/log
exec </dev/null

umask 022
FSTAB=/etc/fstab
TERM="${TERM-minix}"
PATH=/usr/local/bin:/bin:/usr/bin:/usr/sbin:/usr/pkg/bin:/usr/pkg/sbin:/sbin
RC_TZ=/etc/rc.timezone
export TERM PATH

usage()
{
    echo >&2 "Usage: $0 [-saf] start|stop|down"
    exec intr sh
}

up()
{
    # Function to dynamically start a system service
    opt=""
    prefix=$(expr "$1 " : '\(-\)')
    if [ "$prefix" = "-" ];
    then
         opt=$1
         shift
    fi
    service=$1
    shift

    service $opt up /sbin/$service "$@"
}

edit()
{
    # Function to dynamically edit system service settings
    opt=""
    prefix=$(expr "$1 " : '\(-\)')
    if [ "$prefix" = "-" ];
    then
         opt=$1
         shift
    fi
    service=$1
    shift

    # Assume binaries are always in /usr/sbin
    service $opt edit /usr/sbin/$service -label $service "$@" 
}

# This function parses the deprecated minix shellscript-style 
# /etc/fstab, and fscks and mounts its filesystems.
mountfstab_poorman()
{
    # /etc/fstab lists the root, tmp and usr devices.
    . $FSTAB

    # Check if the system crashed.
    if shutdown -C
    then
	echo
	echo "The system was not properly shut down.  Checking file systems."
	fflag=-f
    fi

    if [ -n "$fflag" ]
    then
	echo "fsck.mfs / - $root"
	intr fsck.mfs $fsckopts $root
	echo "fsck.mfs /usr - $usr"
	intr fsck.mfs $fsckopts $usr
	if [ ! -z "$home" ]
	then	echo "fsck.mfs /home - $home"
		intr fsck.mfs $fsckopts $home
	fi
    fi

    # mount /usr
    mount $bin_img $usr /usr

    if [ ! -z "$home" ]
    then mount $bin_img $home /home || echo "WARNING: couldn't mount $home on /home"
    fi
}

while getopts 'saf' opt
do
    case $opt in
    s)	sflag=t ;;	# Single user
    a)	aflag=t ;;	# Ask for /usr
    f)	fflag=-f ;;	# Force a full file system check
    *)	usage
    esac
done
shift `expr $OPTIND - 1`

case "$#:$1" in
1:start|1:stop|1:down)
    action=$1
    ;;
*)  usage
esac

case $action in
start)
    echo -n "Multiuser startup in progress ..."

    # National keyboard?
    test -f /etc/keymap && loadkeys /etc/keymap

    # options for fsck. default is -r, which prompts the user for repairs.
    fsckopts="`sysenv fsckopts`"
    if [ ! "$fsckopts" ]
    then	fsckopts=-r
    fi

    if [ "`sysenv debug_fkeys`" != 0 ]
    then
        up -n is -period 5HZ
    fi
    echo

    # Set timezone.
    export TZ=GMT0
    if [ -f "$RC_TZ" ]
    then . "$RC_TZ"
    fi

    # Try to read the hardware real-time clock, otherwise do it manually.
    readclock || intr date -q

    # Initialize files.
    printroot >/etc/mtab		# /etc/mtab keeps track of mounts
    >/etc/utmp				# /etc/utmp keeps track of logins

    # Unmount now defunct ramdisk
    umount /dev/imgrd > /dev/null || echo "Failed to unmount boot ramdisk"

    # Use MFS binary only from kernel image?
    if [ "`sysenv bin_img`" = 1 ]
    then
        bin_img="-i "
    fi

    # Are we booting from CD?
    bootcd="`/bin/sysenv bootcd`"

    # If booting from CD, mounting is a special case.
    # We know what to do - only /usr is mounted and it's readonly.
    if [ "$bootcd" = 1 ]
    then	usrdev="$cddev"p2
    		echo "/usr on cd is $usrdev"
		mount -r $usrdev /usr
    else	
    # If we're not booting from CD, fsck + mount using /etc/fstab.
		read <$FSTAB fstabline
		if [ "$fstabline" = "# Poor man's File System Table." ]
		then	mountfstab_poorman	# Old minix /etc/fstab
		else	mountfstab $fflag -o"$fsckopts" $FSTAB	
		fi
    fi

    # Edit settings for boot system services
    if [ "`sysenv skip_boot_config`" != 1 ]
    then
	edit rs
	edit vm
	edit pm
	edit sched
	edit vfs
	edit ds
	edit tty
	edit memory
	edit -p log
	edit -c pfs
	edit init
    fi

    # This file is necessary for above 'shutdown -C' check.
    # (Silence stderr in case of running from cd.)
    touch /usr/adm/wtmp /etc/wtmp 2>/dev/null

    if [ "$sflag" ]
    then
	echo "Single user."
	intr sh
    fi

    case "`printroot -r`":$bootcd in
    /dev/ram:)
	# Remove boot-only things to make space,
	# unless booting from CD, in which case we need them.
	rm -rf /boot
	# put the compiler on ram
	cp /usr/lib/em* /usr/lib/cpp* /lib
    esac

    # Things should be alright now.
    ;;
down|stop)
    sync
    # Tell RS server we're going down.
    service shutdown
    ;;
esac

# Further initialization.
test -f /usr/etc/rc && sh /usr/etc/rc $action
test -f /usr/local/etc/rc && sh /usr/local/etc/rc $action

# Any messages?
test "$action" = start -a -f /etc/issue && cat /etc/issue

exit 0
